{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/misc/window.js","webpack:///./src/misc/events.js","webpack:///./src/patch/formdata.js","webpack:///./src/misc/event-emitter.js","webpack:///./src/misc/array.js","webpack:///./src/misc/headers.js","webpack:///./src/misc/hooks.js","webpack:///./src/patch/xmlhttprequest.js","webpack:///./src/patch/fetch.js","webpack:///./src/main.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/amd-options.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","result","WorkerGlobalScope","self","global","window","useragent","navigator","userAgent","msie","test","toLowerCase","parseInt","RegExp","$1","document","UPLOAD_EVENTS","COMMON_EVENTS","depricatedProp","includes","mergeObjects","src","dst","k","v","error","proxyEvents","events","event","e","clone","val","dispatchEvent","Array","from","_has","fakeEvent","type","createEventObject","msieEventObject","Event","Native","FormData","Xhook","form","this","fd","entries","querySelectorAll","filter","checked","map","files","concat","append","args","arguments","push","apply","EventEmitter","nodeStyle","listeners","emitter","callback","indexOf","undefined","length","splice","shift","legacylistener","iterable","on","addEventListener","off","removeEventListener","fire","once","fn","destroy","item","slice","convert","h","dest","headers","join","split","header","$2","hooks","nullify","res","XMLHttpRequest","xhr","request","status","hasError","transiting","response","currentState","readHead","statusText","getAllResponseHeaders","writeHead","facade","emitFinal","readyState","emitReadyState","responseText","text","responseXML","xml","data","responseURL","finalUrl","async","setTimeout","setReadyState","xhook","process","hook","onreadystatechange","responseType","readBody","hasErrorHandler","addWithCredentials","withCredentials","open","method","url","user","pass","headerNames","send","body","modk","upload","setRequestHeader","done","userResponse","head","progress","abort","lName","getResponseHeader","overrideMimeType","up","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","fetch","options","beforeHooks","afterHooks","Promise","resolve","reject","getRequest","Headers","Request","processAfter","Response","processBefore","then","catch","err","before","handler","after","enable","patch","disable","unpatch","define","originalModule","webpackPolyfill","children","g","Function","__webpack_amd_options__"],"mappings":"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","file":"xhook.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","let result = null;\n\n//find global object\nif (\n  typeof WorkerGlobalScope !== \"undefined\" &&\n  self instanceof WorkerGlobalScope\n) {\n  result = self;\n} else if (typeof global !== \"undefined\") {\n  result = global;\n} else if (window) {\n  result = window;\n}\n\n//find IE version\nconst useragent =\n  typeof navigator !== \"undefined\" && navigator[\"useragent\"]\n    ? navigator.userAgent\n    : \"\";\n\nexport let msie = null;\nif (\n  /msie (\\d+)/.test(useragent.toLowerCase()) ||\n  /trident\\/.*; rv:(\\d+)/.test(useragent.toLowerCase())\n) {\n  msie = parseInt(RegExp.$1, 10);\n}\n\nexport const window = result;\nexport const document = result.document;\n","import { document } from \"./window\";\n\nexport const UPLOAD_EVENTS = [\"load\", \"loadend\", \"loadstart\"];\nexport const COMMON_EVENTS = [\"progress\", \"abort\", \"error\", \"timeout\"];\n\nconst depricatedProp = p =>\n  [\"returnValue\", \"totalSize\", \"position\"].includes(p);\n\nexport const mergeObjects = function(src, dst) {\n  for (let k in src) {\n    if (depricatedProp(k)) {\n      continue;\n    }\n    const v = src[k];\n    try {\n      dst[k] = v;\n    } catch (error) {}\n  }\n  return dst;\n};\n\n//proxy events from one emitter to another\nexport const proxyEvents = function(events, src, dst) {\n  const p = event =>\n    function(e) {\n      const clone = {};\n      //copies event, with dst emitter inplace of src\n      for (let k in e) {\n        if (depricatedProp(k)) {\n          continue;\n        }\n        const val = e[k];\n        clone[k] = val === src ? dst : val;\n      }\n      //emits out the dst\n      return dst.dispatchEvent(event, clone);\n    };\n  //dont proxy manual events\n  for (let event of Array.from(events)) {\n    if (dst._has(event)) {\n      src[`on${event}`] = p(event);\n    }\n  }\n};\n\n//create fake event\nexport const fakeEvent = function(type) {\n  if (document && document.createEventObject != null) {\n    const msieEventObject = document.createEventObject();\n    msieEventObject.type = type;\n    return msieEventObject;\n  }\n  // on some platforms like android 4.1.2 and safari on windows, it appears\n  // that new Event is not allowed\n  try {\n    return new Event(type);\n  } catch (error) {\n    return { type };\n  }\n};\n","import { window } from \"../misc/window\";\nimport { slice } from \"../misc/array\";\n\n//note:\n// we can patch FormData safely because all XHR\n// is hooked, so we can ensure the real FormData\n// object is used on send\n\n//browser's FormData\nvar Native = window.FormData;\n\n//xhooks's FormData\nconst Xhook = function(form) {\n  this.fd = form ? new Native(form) : new Native();\n  this.form = form;\n  const entries = [];\n  Object.defineProperty(this, \"entries\", {\n    get() {\n      //extract form entries\n      const fentries = !form\n        ? []\n        : slice(form.querySelectorAll(\"input,select\"))\n            .filter(e => ![\"checkbox\", \"radio\"].includes(e.type) || e.checked)\n            .map(e => [e.name, e.type === \"file\" ? e.files : e.value]);\n      //combine with js entries\n      return fentries.concat(entries);\n    }\n  });\n  this.append = function() {\n    const args = slice(arguments);\n    entries.push(args);\n    return this.fd.append.apply(this.fd, args);\n  }.bind(this);\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.FormData = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.FormData = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { slice } from \"./array\";\nimport { mergeObjects, fakeEvent } from \"./events\";\n\n//tiny event emitter\nexport const EventEmitter = function(nodeStyle) {\n  //private\n  let events = {};\n  const listeners = event => events[event] || [];\n  //public\n  const emitter = {};\n  emitter.addEventListener = function(event, callback, i) {\n    events[event] = listeners(event);\n    if (events[event].indexOf(callback) >= 0) {\n      return;\n    }\n    i = i === undefined ? events[event].length : i;\n    events[event].splice(i, 0, callback);\n  };\n  emitter.removeEventListener = function(event, callback) {\n    //remove all\n    if (event === undefined) {\n      events = {};\n      return;\n    }\n    //remove all of type event\n    if (callback === undefined) {\n      events[event] = [];\n    }\n    //remove particular handler\n    const i = listeners(event).indexOf(callback);\n    if (i === -1) {\n      return;\n    }\n    listeners(event).splice(i, 1);\n  };\n  emitter.dispatchEvent = function() {\n    const args = slice(arguments);\n    const event = args.shift();\n    if (!nodeStyle) {\n      args[0] = mergeObjects(args[0], fakeEvent(event));\n    }\n    const legacylistener = emitter[`on${event}`];\n    if (legacylistener) {\n      legacylistener.apply(emitter, args);\n    }\n    const iterable = listeners(event).concat(listeners(\"*\"));\n    for (let i = 0; i < iterable.length; i++) {\n      const listener = iterable[i];\n      listener.apply(emitter, args);\n    }\n  };\n  emitter._has = event => !!(events[event] || emitter[`on${event}`]);\n  //add extra aliases\n  if (nodeStyle) {\n    emitter.listeners = event => slice(listeners(event));\n    emitter.on = emitter.addEventListener;\n    emitter.off = emitter.removeEventListener;\n    emitter.fire = emitter.dispatchEvent;\n    emitter.once = function(e, fn) {\n      var fire = function() {\n        emitter.off(e, fire);\n        return fn.apply(null, arguments);\n      };\n      return emitter.on(e, fire);\n    };\n    emitter.destroy = () => (events = {});\n  }\n\n  return emitter;\n};\n","//if required, add 'indexOf' method to Array\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(item) {\n    for (let i = 0; i < this.length; i++) {\n      const x = this[i];\n      if (x === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\nconst slice = (o, n) => Array.prototype.slice.call(o, n);\n\nexport { slice };\n","//helper\nconst convert = function(h, dest) {\n  let name;\n  if (dest == null) {\n    dest = {};\n  }\n  switch (typeof h) {\n    case \"object\":\n      var headers = [];\n      for (let k in h) {\n        const v = h[k];\n        name = k.toLowerCase();\n        headers.push(`${name}:\\t${v}`);\n      }\n      return headers.join(\"\\n\") + \"\\n\";\n    case \"string\":\n      headers = h.split(\"\\n\");\n      for (let header of Array.from(headers)) {\n        if (/([^:]+):\\s*(.+)/.test(header)) {\n          name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;\n          const value = RegExp.$2;\n          if (dest[name] == null) {\n            dest[name] = value;\n          }\n        }\n      }\n      return dest;\n  }\n  return [];\n};\n\nexport default { convert };\n","import { EventEmitter } from \"./event-emitter\";\n\n//global set of hook functions,\n//uses event emitter to store hooks\nconst hooks = EventEmitter(true);\n\nexport default hooks;\n","import { window, msie } from \"../misc/window\";\nimport {\n  proxyEvents,\n  mergeObjects,\n  COMMON_EVENTS,\n  UPLOAD_EVENTS\n} from \"../misc/events\";\nimport { EventEmitter } from \"../misc/event-emitter\";\nimport headers from \"../misc/headers\";\nimport formData from \"./formdata\";\n\nconst nullify = res => (res === undefined ? null : res);\n\n//browser's XMLHttpRequest\nconst Native = window.XMLHttpRequest;\n\n//xhook's XMLHttpRequest\nconst Xhook = function() {\n  const ABORTED = -1;\n  const xhr = new Native();\n\n  //==========================\n  // Extra state\n  const request = {};\n  let status = null;\n  let hasError = undefined;\n  let transiting = undefined;\n  let response = undefined;\n  var currentState = 0;\n\n  //==========================\n  // Private API\n\n  //read results from real xhr into response\n  const readHead = function() {\n    // Accessing attributes on an aborted xhr object will\n    // throw an 'c00c023f error' in IE9 and lower, don't touch it.\n    response.status = status || xhr.status;\n    if (status !== ABORTED || !(msie < 10)) {\n      response.statusText = xhr.statusText;\n    }\n    if (status !== ABORTED) {\n      const object = headers.convert(xhr.getAllResponseHeaders());\n      for (let key in object) {\n        const val = object[key];\n        if (!response.headers[key]) {\n          const name = key.toLowerCase();\n          response.headers[name] = val;\n        }\n      }\n      return;\n    }\n  };\n\n  const readBody = function() {\n    //https://xhr.spec.whatwg.org/\n    if (!xhr.responseType || xhr.responseType === \"text\") {\n      response.text = xhr.responseText;\n      response.data = xhr.responseText;\n      try {\n        response.xml = xhr.responseXML;\n      } catch (error) {}\n      // unable to set responseXML due to response type, we attempt to assign responseXML\n      // when the type is text even though it's against the spec due to several libraries\n      // and browser vendors who allow this behavior. causing these requests to fail when\n      // xhook is installed on a page.\n    } else if (xhr.responseType === \"document\") {\n      response.xml = xhr.responseXML;\n      response.data = xhr.responseXML;\n    } else {\n      response.data = xhr.response;\n    }\n    //new in some browsers\n    if (\"responseURL\" in xhr) {\n      response.finalUrl = xhr.responseURL;\n    }\n  };\n\n  //write response into facade xhr\n  const writeHead = function() {\n    facade.status = response.status;\n    facade.statusText = response.statusText;\n  };\n\n  const writeBody = function() {\n    if (\"text\" in response) {\n      facade.responseText = response.text;\n    }\n    if (\"xml\" in response) {\n      facade.responseXML = response.xml;\n    }\n    if (\"data\" in response) {\n      facade.response = response.data;\n    }\n    if (\"finalUrl\" in response) {\n      facade.responseURL = response.finalUrl;\n    }\n  };\n\n  const emitFinal = function() {\n    if (!hasError) {\n      facade.dispatchEvent(\"load\", {});\n    }\n    facade.dispatchEvent(\"loadend\", {});\n    if (hasError) {\n      facade.readyState = 0;\n    }\n  };\n\n  //ensure ready state 0 through 4 is handled\n  const emitReadyState = function(n) {\n    while (n > currentState && currentState < 4) {\n      facade.readyState = ++currentState;\n      // make fake events for libraries that actually check the type on\n      // the event object\n      if (currentState === 1) {\n        facade.dispatchEvent(\"loadstart\", {});\n      }\n      if (currentState === 2) {\n        writeHead();\n      }\n      if (currentState === 4) {\n        writeHead();\n        writeBody();\n      }\n      facade.dispatchEvent(\"readystatechange\", {});\n      //delay final events incase of error\n      if (currentState === 4) {\n        if (request.async === false) {\n          emitFinal();\n        } else {\n          setTimeout(emitFinal, 0);\n        }\n      }\n    }\n  };\n\n  //control facade ready state\n  const setReadyState = function(n) {\n    //emit events until readyState reaches 4\n    if (n !== 4) {\n      emitReadyState(n);\n      return;\n    }\n    //before emitting 4, run all 'after' hooks in sequence\n    const hooks = xhook.listeners(\"after\");\n    var process = function() {\n      if (hooks.length > 0) {\n        //execute each 'before' hook one at a time\n        const hook = hooks.shift();\n        if (hook.length === 2) {\n          hook(request, response);\n          process();\n        } else if (hook.length === 3 && request.async) {\n          hook(request, response, process);\n        } else {\n          process();\n        }\n      } else {\n        //response ready for reading\n        emitReadyState(4);\n      }\n      return;\n    };\n    process();\n  };\n\n  //==========================\n  // Facade XHR\n  var facade = EventEmitter();\n  request.xhr = facade;\n\n  // Handle the underlying ready state\n  xhr.onreadystatechange = function(event) {\n    //pull status and headers\n    try {\n      if (xhr.readyState === 2) {\n        readHead();\n      }\n    } catch (error) {}\n    //pull response data\n    if (xhr.readyState === 4) {\n      transiting = false;\n      readHead();\n      readBody();\n    }\n\n    setReadyState(xhr.readyState);\n  };\n\n  //mark this xhr as errored\n  const hasErrorHandler = function() {\n    hasError = true;\n  };\n  facade.addEventListener(\"error\", hasErrorHandler);\n  facade.addEventListener(\"timeout\", hasErrorHandler);\n  facade.addEventListener(\"abort\", hasErrorHandler);\n  // progress means we're current downloading...\n  facade.addEventListener(\"progress\", function(event) {\n    if (currentState < 3) {\n      setReadyState(3);\n    } else if (xhr.readyState <= 3) {\n      //until ready (4), each progress event is followed by readystatechange...\n      facade.dispatchEvent(\"readystatechange\", {}); //TODO fake an XHR event\n    }\n  });\n\n  // initialise 'withCredentials' on facade xhr in browsers with it\n  // or if explicitly told to do so\n  if (\"withCredentials\" in xhr || xhook.addWithCredentials) {\n    facade.withCredentials = false;\n  }\n  facade.status = 0;\n\n  // initialise all possible event handlers\n  for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {\n    facade[`on${event}`] = null;\n  }\n\n  facade.open = function(method, url, async, user, pass) {\n    // Initailize empty XHR facade\n    currentState = 0;\n    hasError = false;\n    transiting = false;\n    //reset request\n    request.headers = {};\n    request.headerNames = {};\n    request.status = 0;\n    request.method = method;\n    request.url = url;\n    request.async = async !== false;\n    request.user = user;\n    request.pass = pass;\n    //reset response\n    response = {};\n    response.headers = {};\n    // openned facade xhr (not real xhr)\n    setReadyState(1);\n  };\n\n  facade.send = function(body) {\n    //read xhr settings before hooking\n    let k, modk;\n    for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n      modk = k === \"type\" ? \"responseType\" : k;\n      if (modk in facade) {\n        request[k] = facade[modk];\n      }\n    }\n\n    request.body = body;\n    const send = function() {\n      //proxy all events from real xhr to facade\n      proxyEvents(COMMON_EVENTS, xhr, facade);\n      //proxy all upload events from the real to the upload facade\n      if (facade.upload) {\n        proxyEvents(\n          COMMON_EVENTS.concat(UPLOAD_EVENTS),\n          xhr.upload,\n          facade.upload\n        );\n      }\n\n      //prepare request all at once\n      transiting = true;\n      //perform open\n      xhr.open(\n        request.method,\n        request.url,\n        request.async,\n        request.user,\n        request.pass\n      );\n\n      //write xhr settings\n      for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n        modk = k === \"type\" ? \"responseType\" : k;\n        if (k in request) {\n          xhr[modk] = request[k];\n        }\n      }\n\n      //insert headers\n      for (let header in request.headers) {\n        const value = request.headers[header];\n        if (header) {\n          xhr.setRequestHeader(header, value);\n        }\n      }\n      //extract real formdata\n      if (request.body instanceof formData.Xhook) {\n        request.body = request.body.fd;\n      }\n      //real send!\n      xhr.send(request.body);\n    };\n\n    const hooks = xhook.listeners(\"before\");\n    //process hooks sequentially\n    var process = function() {\n      if (!hooks.length) {\n        return send();\n      }\n      //go to next hook OR optionally provide response\n      const done = function(userResponse) {\n        //break chain - provide dummy response (readyState 4)\n        if (\n          typeof userResponse === \"object\" &&\n          (typeof userResponse.status === \"number\" ||\n            typeof response.status === \"number\")\n        ) {\n          mergeObjects(userResponse, response);\n          if (!(\"data\" in userResponse)) {\n            userResponse.data = userResponse.response || userResponse.text;\n          }\n          setReadyState(4);\n          return;\n        }\n        //continue processing until no hooks left\n        process();\n      };\n      //specifically provide headers (readyState 2)\n      done.head = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(2);\n      };\n      //specifically provide partial text (responseText  readyState 3)\n      done.progress = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(3);\n      };\n\n      const hook = hooks.shift();\n      //async or sync?\n      if (hook.length === 1) {\n        done(hook(request));\n      } else if (hook.length === 2 && request.async) {\n        //async handlers must use an async xhr\n        hook(request, done);\n      } else {\n        //skip async hook on sync requests\n        done();\n      }\n      return;\n    };\n    //kick off\n    process();\n  };\n\n  facade.abort = function() {\n    status = ABORTED;\n    if (transiting) {\n      xhr.abort(); //this will emit an 'abort' for us\n    } else {\n      facade.dispatchEvent(\"abort\", {});\n    }\n  };\n\n  facade.setRequestHeader = function(header, value) {\n    //the first header set is used for all future case-alternatives of 'name'\n    const lName = header != null ? header.toLowerCase() : undefined;\n    const name = (request.headerNames[lName] =\n      request.headerNames[lName] || header);\n    //append header to any previous values\n    if (request.headers[name]) {\n      value = request.headers[name] + \", \" + value;\n    }\n    request.headers[name] = value;\n  };\n  facade.getResponseHeader = header =>\n    nullify(response.headers[header ? header.toLowerCase() : undefined]);\n\n  facade.getAllResponseHeaders = () =>\n    nullify(headers.convert(response.headers));\n\n  //proxy call only when supported\n  if (xhr.overrideMimeType) {\n    facade.overrideMimeType = function() {\n      xhr.overrideMimeType.apply(xhr, arguments);\n    };\n  }\n\n  //create emitter when supported\n  if (xhr.upload) {\n    let up = EventEmitter();\n    facade.upload = up;\n    request.upload = up;\n  }\n\n  facade.UNSENT = 0;\n  facade.OPENED = 1;\n  facade.HEADERS_RECEIVED = 2;\n  facade.LOADING = 3;\n  facade.DONE = 4;\n\n  // fill in default values for an empty XHR object according to the spec\n  facade.response = \"\";\n  facade.responseText = \"\";\n  facade.responseXML = null;\n  facade.readyState = 0;\n  facade.statusText = \"\";\n\n  return facade;\n};\n\nXhook.UNSENT = 0;\nXhook.OPENED = 1;\nXhook.HEADERS_RECEIVED = 2;\nXhook.LOADING = 3;\nXhook.DONE = 4;\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.XMLHttpRequest = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.XMLHttpRequest = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { window } from \"../misc/window\";\nimport { mergeObjects } from \"../misc/events\";\nimport hooks from \"../misc/hooks\";\nimport formData from \"./formdata\";\n\n//browser's fetch\nconst Native = window.fetch;\n\n//xhook's fetch\nconst Xhook = function(url, options) {\n  if (options == null) {\n    options = { headers: {} };\n  }\n  options.url = url;\n  let request = null;\n\n  const beforeHooks = hooks.listeners(\"before\");\n  const afterHooks = hooks.listeners(\"after\");\n\n  return new Promise(function(resolve, reject) {\n    const getRequest = function() {\n      if (options.body instanceof formData.Xhook) {\n        options.body = options.body.fd;\n      }\n\n      if (options.headers) {\n        options.headers = new Headers(options.headers);\n      }\n\n      if (!request) {\n        request = new Request(options.url, options);\n      }\n\n      return mergeObjects(options, request);\n    };\n\n    var processAfter = function(response) {\n      if (!afterHooks.length) {\n        return resolve(response);\n      }\n\n      const hook = afterHooks.shift();\n\n      if (hook.length === 2) {\n        hook(getRequest(), response);\n        return processAfter(response);\n      } else if (hook.length === 3) {\n        return hook(getRequest(), response, processAfter);\n      } else {\n        return processAfter(response);\n      }\n    };\n\n    const done = function(userResponse) {\n      if (userResponse !== undefined) {\n        const response = new Response(\n          userResponse.body || userResponse.text,\n          userResponse\n        );\n        resolve(response);\n        processAfter(response);\n        return;\n      }\n\n      //continue processing until no hooks left\n      processBefore();\n    };\n\n    var processBefore = function() {\n      if (!beforeHooks.length) {\n        send();\n        return;\n      }\n\n      const hook = beforeHooks.shift();\n\n      if (hook.length === 1) {\n        return done(hook(options));\n      } else if (hook.length === 2) {\n        return hook(getRequest(), done);\n      }\n    };\n\n    var send = () =>\n      Native(getRequest())\n        .then(response => processAfter(response))\n        .catch(function(err) {\n          processAfter(err);\n          return reject(err);\n        });\n\n    processBefore();\n  });\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.fetch = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.fetch = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { EventEmitter } from \"./misc/event-emitter\";\nimport { window } from \"./misc/window\";\nimport headers from \"./misc/headers\";\n\n//patchable types\nimport XMLHttpRequest from \"./patch/xmlhttprequest\";\nimport fetch from \"./patch/fetch\";\nimport FormData from \"./patch/formdata\";\n\n//global state\nimport hooks from \"./misc/hooks\";\n//the global hooks event emitter is also the global xhook object\n//(not the best decision in hindsight)\nconst xhook = hooks;\nxhook.EventEmitter = EventEmitter;\n//modify hooks\nxhook.before = function(handler, i) {\n  if (handler.length < 1 || handler.length > 2) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"before\", handler, i);\n};\nxhook.after = function(handler, i) {\n  if (handler.length < 2 || handler.length > 3) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"after\", handler, i);\n};\n\n//globally enable/disable\nxhook.enable = function() {\n  XMLHttpRequest.patch();\n  fetch.patch();\n  FormData.patch();\n};\nxhook.disable = function() {\n  XMLHttpRequest.unpatch();\n  fetch.unpatch();\n  FormData.unpatch();\n};\n//expose native objects\nxhook.XMLHttpRequest = XMLHttpRequest.Native;\nxhook.fetch = fetch.Native;\nxhook.FormData = FormData.Native;\n\n//expose helpers\nxhook.headers = headers.convert;\n\n//enable by default\nxhook.enable();\n\n//publicise (amd+commonjs+window)\nif (typeof define === \"function\" && define.amd) {\n  define(\"xhook\", [], () => xhook);\n} else if (module && typeof module === \"object\" && module.exports) {\n  module.exports = { xhook };\n} else if (window) {\n  window.xhook = xhook;\n}\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n"],"sourceRoot":""}