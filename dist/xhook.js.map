{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///(webpack)/buildin/amd-options.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./src/main.js","webpack:///./src/misc/array.js","webpack:///./src/misc/event-emitter.js","webpack:///./src/misc/events.js","webpack:///./src/misc/headers.js","webpack:///./src/misc/hooks.js","webpack:///./src/misc/window.js","webpack:///./src/patch/fetch.js","webpack:///./src/patch/formdata.js","webpack:///./src/patch/xmlhttprequest.js"],"names":[],"mappings":";;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;;;;;;;;;;;;ACDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoD;AACb;AACF;;AAErC;AACoD;AAClB;AACM;;AAExC;AACiC;AACjC;AACA;AACA,cAAc,mDAAK;AACnB,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,6DAAc;AAChB,EAAE,oDAAK;AACP,EAAE,uDAAQ;AACV;AACA;AACA,EAAE,6DAAc;AAChB,EAAE,oDAAK;AACP,EAAE,uDAAQ;AACV;AACA;AACA,uBAAuB,6DAAc;AACrC,cAAc,oDAAK;AACnB,iBAAiB,uDAAQ;;AAEzB;AACA,gBAAgB,qDAAO;;AAEvB;AACA;;AAEA;AACA,oCAAoC,gGAAU;AAC9C;AACA,CAAC;AACD,oBAAoB;AACpB,CAAC,UAAU,mDAAM;AACjB,EAAE,mDAAM;AACR;;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEiB;;;;;;;;;;;;;ACfjB;AAAA;AAAA;AAAA;AAAgC;AACmB;;AAEnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAK;AACtB;AACA;AACA,gBAAgB,4DAAY,UAAU,yDAAS;AAC/C;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;AACA,iCAAiC,oDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;;AAE7B;AACA;;AAEP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;;AAEA;AACO;AACP,MAAM,gDAAQ,IAAI,gDAAQ;AAC1B,4BAA4B,gDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;AACA;;;;;;;;;;;;;AC3DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK,KAAK,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,gEAAC,UAAU,EAAC;;;;;;;;;;;;;AC/B3B;AAAA;AAA+C;;AAE/C;AACA;AACA,cAAc,mEAAY;;AAEX,oEAAK,EAAC;;;;;;;;;;;;;ACNrB;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEO;AACA;;;;;;;;;;;;;;AC7BP;AAAA;AAAA;AAAA;AAAA;AAAwC;AACM;AACZ;AACA;;AAElC;AACA,eAAe,mDAAM;;AAErB;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;;AAEA,sBAAsB,mDAAK;AAC3B,qBAAqB,mDAAK;;AAE1B;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,iEAAY;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,GAAG;AACH;;AAEA;AACe;AACf;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC7GF;AAAA;AAAA;AAAwC;AACF;;AAEtC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mDAAM;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yDAAK;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB,yDAAK;AACtB;AACA;AACA,GAAG;AACH;;AAEA;AACe;AACf;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACjDF;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AAMtB;AAC6B;AACf;AACJ;;AAElC;;AAEA;AACA,eAAe,mDAAM;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAI;AACpC;AACA;AACA;AACA,qBAAqB,qDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wEAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,EAAE;AACnD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,0DAAa,QAAQ,0DAAa;AACjE,gBAAgB,MAAM;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,gEAAW,CAAC,0DAAa;AAC/B;AACA;AACA,QAAQ,gEAAW;AACnB,UAAU,0DAAa,QAAQ,0DAAa;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAQ;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iEAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iEAAY;AACpB;AACA;AACA;AACA;AACA,QAAQ,iEAAY;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,qDAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,wEAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,MAAM,mDAAM;AACZ;AACA,GAAG;AACH;AACA;AACA,CAAC,EAAC","file":"xhook.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/main.js\");\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import { EventEmitter } from \"./misc/event-emitter\";\nimport { window } from \"./misc/window\";\nimport headers from \"./misc/headers\";\n\n//patchable types\nimport XMLHttpRequest from \"./patch/xmlhttprequest\";\nimport fetch from \"./patch/fetch\";\nimport FormData from \"./patch/formdata\";\n\n//global state\nimport hooks from \"./misc/hooks\";\n//the global hooks event emitter is also the global xhook object\n//(not the best decision in hindsight)\nconst xhook = hooks;\nxhook.EventEmitter = EventEmitter;\n//modify hooks\nxhook.before = function(handler, i) {\n  if (handler.length < 1 || handler.length > 2) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"before\", handler, i);\n};\nxhook.after = function(handler, i) {\n  if (handler.length < 2 || handler.length > 3) {\n    throw \"invalid hook\";\n  }\n  return xhook.on(\"after\", handler, i);\n};\n\n//globally enable/disable\nxhook.enable = function() {\n  XMLHttpRequest.patch();\n  fetch.patch();\n  FormData.patch();\n};\nxhook.disable = function() {\n  XMLHttpRequest.unpatch();\n  fetch.unpatch();\n  FormData.unpatch();\n};\n//expose native objects\nxhook.XMLHttpRequest = XMLHttpRequest.Native;\nxhook.fetch = fetch.Native;\nxhook.FormData = FormData.Native;\n\n//expose helpers\nxhook.headers = headers.convert;\n\n//enable by default\nxhook.enable();\n\n//publicise (amd+commonjs+window)\nif (typeof define === \"function\" && define.amd) {\n  define(\"xhook\", [], () => xhook);\n} else if (module && typeof module === \"object\" && module.exports) {\n  module.exports = { xhook };\n} else if (window) {\n  window.xhook = xhook;\n}\n","//if required, add 'indexOf' method to Array\nif (!Array.prototype.indexOf) {\n  Array.prototype.indexOf = function(item) {\n    for (let i = 0; i < this.length; i++) {\n      const x = this[i];\n      if (x === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\nconst slice = (o, n) => Array.prototype.slice.call(o, n);\n\nexport { slice };\n","import { slice } from \"./array\";\nimport { mergeObjects, fakeEvent } from \"./events\";\n\n//tiny event emitter\nexport const EventEmitter = function(nodeStyle) {\n  //private\n  let events = {};\n  const listeners = event => events[event] || [];\n  //public\n  const emitter = {};\n  emitter.addEventListener = function(event, callback, i) {\n    events[event] = listeners(event);\n    if (events[event].indexOf(callback) >= 0) {\n      return;\n    }\n    i = i === undefined ? events[event].length : i;\n    events[event].splice(i, 0, callback);\n  };\n  emitter.removeEventListener = function(event, callback) {\n    //remove all\n    if (event === undefined) {\n      events = {};\n      return;\n    }\n    //remove all of type event\n    if (callback === undefined) {\n      events[event] = [];\n    }\n    //remove particular handler\n    const i = listeners(event).indexOf(callback);\n    if (i === -1) {\n      return;\n    }\n    listeners(event).splice(i, 1);\n  };\n  emitter.dispatchEvent = function() {\n    const args = slice(arguments);\n    const event = args.shift();\n    if (!nodeStyle) {\n      args[0] = mergeObjects(args[0], fakeEvent(event));\n    }\n    const legacylistener = emitter[`on${event}`];\n    if (legacylistener) {\n      legacylistener.apply(emitter, args);\n    }\n    const iterable = listeners(event).concat(listeners(\"*\"));\n    for (let i = 0; i < iterable.length; i++) {\n      const listener = iterable[i];\n      listener.apply(emitter, args);\n    }\n  };\n  emitter._has = event => !!(events[event] || emitter[`on${event}`]);\n  //add extra aliases\n  if (nodeStyle) {\n    emitter.listeners = event => slice(listeners(event));\n    emitter.on = emitter.addEventListener;\n    emitter.off = emitter.removeEventListener;\n    emitter.fire = emitter.dispatchEvent;\n    emitter.once = function(e, fn) {\n      var fire = function() {\n        emitter.off(e, fire);\n        return fn.apply(null, arguments);\n      };\n      return emitter.on(e, fire);\n    };\n    emitter.destroy = () => (events = {});\n  }\n\n  return emitter;\n};\n","import { document } from \"./window\";\n\nexport const UPLOAD_EVENTS = [\"load\", \"loadend\", \"loadstart\"];\nexport const COMMON_EVENTS = [\"progress\", \"abort\", \"error\", \"timeout\"];\n\nconst depricatedProp = p =>\n  [\"returnValue\", \"totalSize\", \"position\"].includes(p);\n\nexport const mergeObjects = function(src, dst) {\n  for (let k in src) {\n    if (depricatedProp(k)) {\n      continue;\n    }\n    const v = src[k];\n    try {\n      dst[k] = v;\n    } catch (error) {}\n  }\n  return dst;\n};\n\n//proxy events from one emitter to another\nexport const proxyEvents = function(events, src, dst) {\n  const p = event =>\n    function(e) {\n      const clone = {};\n      //copies event, with dst emitter inplace of src\n      for (let k in e) {\n        if (depricatedProp(k)) {\n          continue;\n        }\n        const val = e[k];\n        clone[k] = val === src ? dst : val;\n      }\n      //emits out the dst\n      return dst.dispatchEvent(event, clone);\n    };\n  //dont proxy manual events\n  for (let event of Array.from(events)) {\n    if (dst._has(event)) {\n      src[`on${event}`] = p(event);\n    }\n  }\n};\n\n//create fake event\nexport const fakeEvent = function(type) {\n  if (document && document.createEventObject != null) {\n    const msieEventObject = document.createEventObject();\n    msieEventObject.type = type;\n    return msieEventObject;\n  }\n  // on some platforms like android 4.1.2 and safari on windows, it appears\n  // that new Event is not allowed\n  try {\n    return new Event(type);\n  } catch (error) {\n    return { type };\n  }\n};\n","//helper\nconst convert = function(h, dest) {\n  let name;\n  if (dest == null) {\n    dest = {};\n  }\n  switch (typeof h) {\n    case \"object\":\n      var headers = [];\n      for (let k in h) {\n        const v = h[k];\n        name = k.toLowerCase();\n        headers.push(`${name}:\\t${v}`);\n      }\n      return headers.join(\"\\n\") + \"\\n\";\n    case \"string\":\n      headers = h.split(\"\\n\");\n      for (let header of Array.from(headers)) {\n        if (/([^:]+):\\s*(.+)/.test(header)) {\n          name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;\n          const value = RegExp.$2;\n          if (dest[name] == null) {\n            dest[name] = value;\n          }\n        }\n      }\n      return dest;\n  }\n  return [];\n};\n\nexport default { convert };\n","import { EventEmitter } from \"./event-emitter\";\n\n//global set of hook functions,\n//uses event emitter to store hooks\nconst hooks = EventEmitter(true);\n\nexport default hooks;\n","let result = null;\n\n//find global object\nif (\n  typeof WorkerGlobalScope !== \"undefined\" &&\n  self instanceof WorkerGlobalScope\n) {\n  result = self;\n} else if (typeof global !== \"undefined\") {\n  result = global;\n} else if (window) {\n  result = window;\n}\n\n//find IE version\nconst useragent =\n  typeof navigator !== \"undefined\" && navigator[\"useragent\"]\n    ? navigator.userAgent\n    : \"\";\n\nexport let msie = null;\nif (\n  /msie (\\d+)/.test(useragent.toLowerCase()) ||\n  /trident\\/.*; rv:(\\d+)/.test(useragent.toLowerCase())\n) {\n  msie = parseInt(RegExp.$1, 10);\n}\n\nexport const window = result;\nexport const document = result.document;\n","import { window } from \"../misc/window\";\nimport { mergeObjects } from \"../misc/events\";\nimport hooks from \"../misc/hooks\";\nimport formData from \"./formdata\";\n\n//browser's fetch\nconst Native = window.fetch;\n\n//xhook's fetch\nconst Xhook = function(url, options) {\n  if (options == null) {\n    options = { headers: {} };\n  }\n  options.url = url;\n  let request = null;\n\n  const beforeHooks = hooks.listeners(\"before\");\n  const afterHooks = hooks.listeners(\"after\");\n\n  return new Promise(function(resolve, reject) {\n    const getRequest = function() {\n      if (options.body instanceof formData.Xhook) {\n        options.body = options.body.fd;\n      }\n\n      if (options.headers) {\n        options.headers = new Headers(options.headers);\n      }\n\n      if (!request) {\n        request = new Request(options.url, options);\n      }\n\n      return mergeObjects(options, request);\n    };\n\n    var processAfter = function(response) {\n      if (!afterHooks.length) {\n        return resolve(response);\n      }\n\n      const hook = afterHooks.shift();\n\n      if (hook.length === 2) {\n        hook(getRequest(), response);\n        return processAfter(response);\n      } else if (hook.length === 3) {\n        return hook(getRequest(), response, processAfter);\n      } else {\n        return processAfter(response);\n      }\n    };\n\n    const done = function(userResponse) {\n      if (userResponse !== undefined) {\n        const response = new Response(\n          userResponse.body || userResponse.text,\n          userResponse\n        );\n        resolve(response);\n        processAfter(response);\n        return;\n      }\n\n      //continue processing until no hooks left\n      processBefore();\n    };\n\n    var processBefore = function() {\n      if (!beforeHooks.length) {\n        send();\n        return;\n      }\n\n      const hook = beforeHooks.shift();\n\n      if (hook.length === 1) {\n        return done(hook(options));\n      } else if (hook.length === 2) {\n        return hook(getRequest(), done);\n      }\n    };\n\n    var send = () =>\n      Native(getRequest())\n        .then(response => processAfter(response))\n        .catch(function(err) {\n          processAfter(err);\n          return reject(err);\n        });\n\n    processBefore();\n  });\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.fetch = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.fetch = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { window } from \"../misc/window\";\nimport { slice } from \"../misc/array\";\n\n//note:\n// we can patch FormData safely because all XHR\n// is hooked, so we can ensure the real FormData\n// object is used on send\n\n//browser's FormData\nvar Native = window.FormData;\n\n//xhooks's FormData\nconst Xhook = function(form) {\n  this.fd = form ? new Native(form) : new Native();\n  this.form = form;\n  const entries = [];\n  Object.defineProperty(this, \"entries\", {\n    get() {\n      //extract form entries\n      const fentries = !form\n        ? []\n        : slice(form.querySelectorAll(\"input,select\"))\n            .filter(e => ![\"checkbox\", \"radio\"].includes(e.type) || e.checked)\n            .map(e => [e.name, e.type === \"file\" ? e.files : e.value]);\n      //combine with js entries\n      return fentries.concat(entries);\n    }\n  });\n  this.append = function() {\n    const args = slice(arguments);\n    entries.push(args);\n    return this.fd.append.apply(this.fd, args);\n  }.bind(this);\n};\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.FormData = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.FormData = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n","import { window, msie } from \"../misc/window\";\nimport {\n  proxyEvents,\n  mergeObjects,\n  COMMON_EVENTS,\n  UPLOAD_EVENTS\n} from \"../misc/events\";\nimport { EventEmitter } from \"../misc/event-emitter\";\nimport headers from \"../misc/headers\";\nimport formData from \"./formdata\";\n\nconst nullify = res => (res === undefined ? null : res);\n\n//browser's XMLHttpRequest\nconst Native = window.XMLHttpRequest;\n\n//xhook's XMLHttpRequest\nconst Xhook = function() {\n  const ABORTED = -1;\n  const xhr = new Native();\n\n  //==========================\n  // Extra state\n  const request = {};\n  let status = null;\n  let hasError = undefined;\n  let transiting = undefined;\n  let response = undefined;\n  var currentState = 0;\n\n  //==========================\n  // Private API\n\n  //read results from real xhr into response\n  const readHead = function() {\n    // Accessing attributes on an aborted xhr object will\n    // throw an 'c00c023f error' in IE9 and lower, don't touch it.\n    response.status = status || xhr.status;\n    if (status !== ABORTED || !(msie < 10)) {\n      response.statusText = xhr.statusText;\n    }\n    if (status !== ABORTED) {\n      const object = headers.convert(xhr.getAllResponseHeaders());\n      for (let key in object) {\n        const val = object[key];\n        if (!response.headers[key]) {\n          const name = key.toLowerCase();\n          response.headers[name] = val;\n        }\n      }\n      return;\n    }\n  };\n\n  const readBody = function() {\n    //https://xhr.spec.whatwg.org/\n    if (!xhr.responseType || xhr.responseType === \"text\") {\n      response.text = xhr.responseText;\n      response.data = xhr.responseText;\n      try {\n        response.xml = xhr.responseXML;\n      } catch (error) {}\n      // unable to set responseXML due to response type, we attempt to assign responseXML\n      // when the type is text even though it's against the spec due to several libraries\n      // and browser vendors who allow this behavior. causing these requests to fail when\n      // xhook is installed on a page.\n    } else if (xhr.responseType === \"document\") {\n      response.xml = xhr.responseXML;\n      response.data = xhr.responseXML;\n    } else {\n      response.data = xhr.response;\n    }\n    //new in some browsers\n    if (\"responseURL\" in xhr) {\n      response.finalUrl = xhr.responseURL;\n    }\n  };\n\n  //write response into facade xhr\n  const writeHead = function() {\n    facade.status = response.status;\n    facade.statusText = response.statusText;\n  };\n\n  const writeBody = function() {\n    if (\"text\" in response) {\n      facade.responseText = response.text;\n    }\n    if (\"xml\" in response) {\n      facade.responseXML = response.xml;\n    }\n    if (\"data\" in response) {\n      facade.response = response.data;\n    }\n    if (\"finalUrl\" in response) {\n      facade.responseURL = response.finalUrl;\n    }\n  };\n\n  const emitFinal = function() {\n    if (!hasError) {\n      facade.dispatchEvent(\"load\", {});\n    }\n    facade.dispatchEvent(\"loadend\", {});\n    if (hasError) {\n      facade.readyState = 0;\n    }\n  };\n\n  //ensure ready state 0 through 4 is handled\n  const emitReadyState = function(n) {\n    while (n > currentState && currentState < 4) {\n      facade.readyState = ++currentState;\n      // make fake events for libraries that actually check the type on\n      // the event object\n      if (currentState === 1) {\n        facade.dispatchEvent(\"loadstart\", {});\n      }\n      if (currentState === 2) {\n        writeHead();\n      }\n      if (currentState === 4) {\n        writeHead();\n        writeBody();\n      }\n      facade.dispatchEvent(\"readystatechange\", {});\n      //delay final events incase of error\n      if (currentState === 4) {\n        if (request.async === false) {\n          emitFinal();\n        } else {\n          setTimeout(emitFinal, 0);\n        }\n      }\n    }\n  };\n\n  //control facade ready state\n  const setReadyState = function(n) {\n    //emit events until readyState reaches 4\n    if (n !== 4) {\n      emitReadyState(n);\n      return;\n    }\n    //before emitting 4, run all 'after' hooks in sequence\n    const hooks = xhook.listeners(\"after\");\n    var process = function() {\n      if (hooks.length > 0) {\n        //execute each 'before' hook one at a time\n        const hook = hooks.shift();\n        if (hook.length === 2) {\n          hook(request, response);\n          process();\n        } else if (hook.length === 3 && request.async) {\n          hook(request, response, process);\n        } else {\n          process();\n        }\n      } else {\n        //response ready for reading\n        emitReadyState(4);\n      }\n      return;\n    };\n    process();\n  };\n\n  //==========================\n  // Facade XHR\n  var facade = EventEmitter();\n  request.xhr = facade;\n\n  // Handle the underlying ready state\n  xhr.onreadystatechange = function(event) {\n    //pull status and headers\n    try {\n      if (xhr.readyState === 2) {\n        readHead();\n      }\n    } catch (error) {}\n    //pull response data\n    if (xhr.readyState === 4) {\n      transiting = false;\n      readHead();\n      readBody();\n    }\n\n    setReadyState(xhr.readyState);\n  };\n\n  //mark this xhr as errored\n  const hasErrorHandler = function() {\n    hasError = true;\n  };\n  facade.addEventListener(\"error\", hasErrorHandler);\n  facade.addEventListener(\"timeout\", hasErrorHandler);\n  facade.addEventListener(\"abort\", hasErrorHandler);\n  // progress means we're current downloading...\n  facade.addEventListener(\"progress\", function(event) {\n    if (currentState < 3) {\n      setReadyState(3);\n    } else if (xhr.readyState <= 3) {\n      //until ready (4), each progress event is followed by readystatechange...\n      facade.dispatchEvent(\"readystatechange\", {}); //TODO fake an XHR event\n    }\n  });\n\n  // initialise 'withCredentials' on facade xhr in browsers with it\n  // or if explicitly told to do so\n  if (\"withCredentials\" in xhr || xhook.addWithCredentials) {\n    facade.withCredentials = false;\n  }\n  facade.status = 0;\n\n  // initialise all possible event handlers\n  for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {\n    facade[`on${event}`] = null;\n  }\n\n  facade.open = function(method, url, async, user, pass) {\n    // Initailize empty XHR facade\n    currentState = 0;\n    hasError = false;\n    transiting = false;\n    //reset request\n    request.headers = {};\n    request.headerNames = {};\n    request.status = 0;\n    request.method = method;\n    request.url = url;\n    request.async = async !== false;\n    request.user = user;\n    request.pass = pass;\n    //reset response\n    response = {};\n    response.headers = {};\n    // openned facade xhr (not real xhr)\n    setReadyState(1);\n  };\n\n  facade.send = function(body) {\n    //read xhr settings before hooking\n    let k, modk;\n    for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n      modk = k === \"type\" ? \"responseType\" : k;\n      if (modk in facade) {\n        request[k] = facade[modk];\n      }\n    }\n\n    request.body = body;\n    const send = function() {\n      //proxy all events from real xhr to facade\n      proxyEvents(COMMON_EVENTS, xhr, facade);\n      //proxy all upload events from the real to the upload facade\n      if (facade.upload) {\n        proxyEvents(\n          COMMON_EVENTS.concat(UPLOAD_EVENTS),\n          xhr.upload,\n          facade.upload\n        );\n      }\n\n      //prepare request all at once\n      transiting = true;\n      //perform open\n      xhr.open(\n        request.method,\n        request.url,\n        request.async,\n        request.user,\n        request.pass\n      );\n\n      //write xhr settings\n      for (k of [\"type\", \"timeout\", \"withCredentials\"]) {\n        modk = k === \"type\" ? \"responseType\" : k;\n        if (k in request) {\n          xhr[modk] = request[k];\n        }\n      }\n\n      //insert headers\n      for (let header in request.headers) {\n        const value = request.headers[header];\n        if (header) {\n          xhr.setRequestHeader(header, value);\n        }\n      }\n      //extract real formdata\n      if (request.body instanceof formData.Xhook) {\n        request.body = request.body.fd;\n      }\n      //real send!\n      xhr.send(request.body);\n    };\n\n    const hooks = xhook.listeners(\"before\");\n    //process hooks sequentially\n    var process = function() {\n      if (!hooks.length) {\n        return send();\n      }\n      //go to next hook OR optionally provide response\n      const done = function(userResponse) {\n        //break chain - provide dummy response (readyState 4)\n        if (\n          typeof userResponse === \"object\" &&\n          (typeof userResponse.status === \"number\" ||\n            typeof response.status === \"number\")\n        ) {\n          mergeObjects(userResponse, response);\n          if (!(\"data\" in userResponse)) {\n            userResponse.data = userResponse.response || userResponse.text;\n          }\n          setReadyState(4);\n          return;\n        }\n        //continue processing until no hooks left\n        process();\n      };\n      //specifically provide headers (readyState 2)\n      done.head = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(2);\n      };\n      //specifically provide partial text (responseText  readyState 3)\n      done.progress = function(userResponse) {\n        mergeObjects(userResponse, response);\n        setReadyState(3);\n      };\n\n      const hook = hooks.shift();\n      //async or sync?\n      if (hook.length === 1) {\n        done(hook(request));\n      } else if (hook.length === 2 && request.async) {\n        //async handlers must use an async xhr\n        hook(request, done);\n      } else {\n        //skip async hook on sync requests\n        done();\n      }\n      return;\n    };\n    //kick off\n    process();\n  };\n\n  facade.abort = function() {\n    status = ABORTED;\n    if (transiting) {\n      xhr.abort(); //this will emit an 'abort' for us\n    } else {\n      facade.dispatchEvent(\"abort\", {});\n    }\n  };\n\n  facade.setRequestHeader = function(header, value) {\n    //the first header set is used for all future case-alternatives of 'name'\n    const lName = header != null ? header.toLowerCase() : undefined;\n    const name = (request.headerNames[lName] =\n      request.headerNames[lName] || header);\n    //append header to any previous values\n    if (request.headers[name]) {\n      value = request.headers[name] + \", \" + value;\n    }\n    request.headers[name] = value;\n  };\n  facade.getResponseHeader = header =>\n    nullify(response.headers[header ? header.toLowerCase() : undefined]);\n\n  facade.getAllResponseHeaders = () =>\n    nullify(headers.convert(response.headers));\n\n  //proxy call only when supported\n  if (xhr.overrideMimeType) {\n    facade.overrideMimeType = function() {\n      xhr.overrideMimeType.apply(xhr, arguments);\n    };\n  }\n\n  //create emitter when supported\n  if (xhr.upload) {\n    let up = EventEmitter();\n    facade.upload = up;\n    request.upload = up;\n  }\n\n  facade.UNSENT = 0;\n  facade.OPENED = 1;\n  facade.HEADERS_RECEIVED = 2;\n  facade.LOADING = 3;\n  facade.DONE = 4;\n\n  // fill in default values for an empty XHR object according to the spec\n  facade.response = \"\";\n  facade.responseText = \"\";\n  facade.responseXML = null;\n  facade.readyState = 0;\n  facade.statusText = \"\";\n\n  return facade;\n};\n\nXhook.UNSENT = 0;\nXhook.OPENED = 1;\nXhook.HEADERS_RECEIVED = 2;\nXhook.LOADING = 3;\nXhook.DONE = 4;\n\n//patch interface\nexport default {\n  patch() {\n    if (Native) {\n      window.XMLHttpRequest = Xhook;\n    }\n  },\n  unpatch() {\n    if (Native) {\n      window.XMLHttpRequest = Native;\n    }\n  },\n  Native,\n  Xhook\n};\n"],"sourceRoot":""}